BEGIN;

-- =========================================================
-- 0) 확장
-- =========================================================
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS "pgcrypto";

-- =========================================================
-- 1) 표준 테이블 (없으면 생성) + 누락 컬럼 보강
-- =========================================================
CREATE TABLE IF NOT EXISTS public.workers (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(100) NOT NULL,
  daily           NUMERIC(12,2) DEFAULT 0,
  hourly_rate     NUMERIC(10,2) DEFAULT 0,
  monthly_salary  NUMERIC(12,2) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.workers
  ADD COLUMN IF NOT EXISTS name            VARCHAR(100),
  ADD COLUMN IF NOT EXISTS daily           NUMERIC(12,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS hourly_rate     NUMERIC(10,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS monthly_salary  NUMERIC(12,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS created_at      TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS updated_at      TIMESTAMPTZ;
ALTER TABLE public.workers
  ALTER COLUMN created_at SET DEFAULT NOW(),
  ALTER COLUMN updated_at SET DEFAULT NOW();

CREATE TABLE IF NOT EXISTS public.sites (
  id BIGSERIAL PRIMARY KEY,
  name VARCHAR(200) NOT NULL,
  address TEXT,
  manager VARCHAR(100),
  status TEXT DEFAULT '',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.sites
  ADD COLUMN IF NOT EXISTS name        VARCHAR(200),
  ADD COLUMN IF NOT EXISTS address     TEXT,
  ADD COLUMN IF NOT EXISTS manager     VARCHAR(100),
  ADD COLUMN IF NOT EXISTS status      TEXT,
  ADD COLUMN IF NOT EXISTS created_at  TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS updated_at  TIMESTAMPTZ;
ALTER TABLE public.sites
  ALTER COLUMN created_at SET DEFAULT NOW(),
  ALTER COLUMN updated_at SET DEFAULT NOW(),
  ALTER COLUMN status SET DEFAULT '';

CREATE TABLE IF NOT EXISTS public.work_records (
  id BIGSERIAL PRIMARY KEY,
  date DATE NOT NULL,
  site VARCHAR(200) NOT NULL,
  worker VARCHAR(100) NOT NULL,
  days  NUMERIC(6,2) DEFAULT 0,
  hours NUMERIC(6,2) DEFAULT 0,
  memo  TEXT,
  total_salary NUMERIC(12,2) DEFAULT 0,
  tax          NUMERIC(12,2) DEFAULT 0,
  net_salary   NUMERIC(12,2) DEFAULT 0,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.work_records
  ADD COLUMN IF NOT EXISTS date         DATE,
  ADD COLUMN IF NOT EXISTS site         VARCHAR(200),
  ADD COLUMN IF NOT EXISTS worker       VARCHAR(100),
  ADD COLUMN IF NOT EXISTS days         NUMERIC(6,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS hours        NUMERIC(6,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS memo         TEXT,
  ADD COLUMN IF NOT EXISTS total_salary NUMERIC(12,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS tax          NUMERIC(12,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS net_salary   NUMERIC(12,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS created_at   TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS updated_at   TIMESTAMPTZ;
ALTER TABLE public.work_records
  ALTER COLUMN created_at SET DEFAULT NOW(),
  ALTER COLUMN updated_at SET DEFAULT NOW();

CREATE TABLE IF NOT EXISTS public.expense_records (
  id BIGSERIAL PRIMARY KEY,
  date DATE NOT NULL,
  site VARCHAR(200) NOT NULL,
  worker   VARCHAR(100),
  category VARCHAR(100) NOT NULL,
  amount   NUMERIC(12,2) NOT NULL DEFAULT 0,
  location VARCHAR(200),
  address  TEXT,
  memo     TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.expense_records
  ADD COLUMN IF NOT EXISTS date       DATE,
  ADD COLUMN IF NOT EXISTS site       VARCHAR(200),
  ADD COLUMN IF NOT EXISTS worker     VARCHAR(100),
  ADD COLUMN IF NOT EXISTS category   VARCHAR(100),
  ADD COLUMN IF NOT EXISTS amount     NUMERIC(12,2) DEFAULT 0,
  ADD COLUMN IF NOT EXISTS location   VARCHAR(200),
  ADD COLUMN IF NOT EXISTS address    TEXT,
  ADD COLUMN IF NOT EXISTS memo       TEXT,
  ADD COLUMN IF NOT EXISTS created_at TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS updated_at TIMESTAMPTZ;
ALTER TABLE public.expense_records
  ALTER COLUMN created_at SET DEFAULT NOW(),
  ALTER COLUMN updated_at SET DEFAULT NOW();

CREATE TABLE IF NOT EXISTS public.system_config (
  id BIGSERIAL PRIMARY KEY,
  key VARCHAR(100) UNIQUE NOT NULL,
  value TEXT,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
ALTER TABLE public.system_config
  ADD COLUMN IF NOT EXISTS key         VARCHAR(100),
  ADD COLUMN IF NOT EXISTS value       TEXT,
  ADD COLUMN IF NOT EXISTS description TEXT,
  ADD COLUMN IF NOT EXISTS created_at  TIMESTAMPTZ,
  ADD COLUMN IF NOT EXISTS updated_at  TIMESTAMPTZ;
ALTER TABLE public.system_config
  ALTER COLUMN created_at SET DEFAULT NOW(),
  ALTER COLUMN updated_at SET DEFAULT NOW();

INSERT INTO public.system_config(key,value,description) VALUES
('tax_rate','3.3','기본 세율(%)'),
('default_daily_hours','8','1일 근무시간(시간)'),
('default_business_days','30','월 환산 기준일수')
ON CONFLICT (key) DO NOTHING;

-- 기존 행 created_at/updated_at 백필
UPDATE public.workers         SET created_at = NOW() WHERE created_at IS NULL;
UPDATE public.sites           SET created_at = NOW() WHERE created_at IS NULL;
UPDATE public.work_records    SET created_at = NOW() WHERE created_at IS NULL;
UPDATE public.expense_records SET created_at = NOW() WHERE created_at IS NULL;
UPDATE public.system_config   SET created_at = NOW() WHERE created_at IS NULL;

UPDATE public.workers         SET updated_at = NOW() WHERE updated_at IS NULL;
UPDATE public.sites           SET updated_at = NOW() WHERE updated_at IS NULL;
UPDATE public.work_records    SET updated_at = NOW() WHERE updated_at IS NULL;
UPDATE public.expense_records SET updated_at = NOW() WHERE updated_at IS NULL;
UPDATE public.system_config   SET updated_at = NOW() WHERE updated_at IS NULL;

-- =========================================================
-- 2) 일반 인덱스
-- =========================================================
CREATE INDEX IF NOT EXISTS idx_workers_name   ON public.workers(name);
CREATE INDEX IF NOT EXISTS idx_sites_name     ON public.sites(name);

CREATE INDEX IF NOT EXISTS idx_wr_date        ON public.work_records(date);
CREATE INDEX IF NOT EXISTS idx_wr_site        ON public.work_records(site);
CREATE INDEX IF NOT EXISTS idx_wr_worker      ON public.work_records(worker);
CREATE INDEX IF NOT EXISTS idx_wr_date_worker ON public.work_records(date, worker);
-- 조회 최적화(현장+날짜 내림차순)
CREATE INDEX IF NOT EXISTS idx_wr_site_date   ON public.work_records(site, date DESC);

CREATE INDEX IF NOT EXISTS idx_er_date        ON public.expense_records(date);
CREATE INDEX IF NOT EXISTS idx_er_site        ON public.expense_records(site);
CREATE INDEX IF NOT EXISTS idx_er_category    ON public.expense_records(category);

-- =========================================================
-- 3) 트리거 함수 + 트리거 (중복 정리 전에 정의하여 UPDATE 시 급여 재계산 적용)
-- =========================================================
-- updated_at 자동 갱신
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  IF EXISTS (
    SELECT 1 FROM information_schema.columns
    WHERE table_schema = TG_TABLE_SCHEMA
      AND table_name   = TG_TABLE_NAME
      AND column_name  = 'updated_at'
  ) THEN
    NEW.updated_at := NOW();
  END IF;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 급여 계산: 일당 > 시급×일기준시간 > 월급÷월기준일수
CREATE OR REPLACE FUNCTION public.calculate_work_salary()
RETURNS TRIGGER AS $$
DECLARE
  dl NUMERIC(12,2) := 0;
  hr NUMERIC(12,2) := 0;
  ms NUMERIC(12,2) := 0;
  daily_equiv NUMERIC(12,2) := 0;
  tax_rate NUMERIC(6,3) := COALESCE((SELECT value::numeric FROM public.system_config WHERE key='tax_rate' LIMIT 1), 3.3);
  daily_hours NUMERIC(6,2) := COALESCE((SELECT value::numeric FROM public.system_config WHERE key='default_daily_hours' LIMIT 1), 8);
  business_days NUMERIC(6,2) := COALESCE((SELECT value::numeric FROM public.system_config WHERE key='default_business_days' LIMIT 1), 30);
BEGIN
  SELECT COALESCE(daily,0), COALESCE(hourly_rate,0), COALESCE(monthly_salary,0)
    INTO dl, hr, ms
    FROM public.workers
   WHERE name = NEW.worker
   LIMIT 1;

  IF dl > 0 THEN
    daily_equiv := dl;
  ELSIF hr > 0 THEN
    daily_equiv := hr * daily_hours;
  ELSIF ms > 0 THEN
    daily_equiv := ms / NULLIF(business_days,0);
  ELSE
    daily_equiv := 0;
  END IF;

  IF COALESCE(NEW.days,0)=0 AND COALESCE(NEW.hours,0)>0 THEN
    NEW.days := NEW.hours / NULLIF(daily_hours,0);
  END IF;

  NEW.total_salary := COALESCE(NEW.days,0) * COALESCE(daily_equiv,0);
  NEW.tax          := NEW.total_salary * (tax_rate/100.0);
  NEW.net_salary   := NEW.total_salary - NEW.tax;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 트리거 부착(없으면 생성)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trigger_calculate_work_salary') THEN
    CREATE TRIGGER trigger_calculate_work_salary
      BEFORE INSERT OR UPDATE ON public.work_records
      FOR EACH ROW EXECUTE FUNCTION public.calculate_work_salary();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trigger_update_work_records_updated_at') THEN
    CREATE TRIGGER trigger_update_work_records_updated_at
      BEFORE UPDATE ON public.work_records
      FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trigger_update_expense_records_updated_at') THEN
    CREATE TRIGGER trigger_update_expense_records_updated_at
      BEFORE UPDATE ON public.expense_records
      FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trigger_update_workers_updated_at') THEN
    CREATE TRIGGER trigger_update_workers_updated_at
      BEFORE UPDATE ON public.workers
      FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
  END IF;

  IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname='trigger_update_sites_updated_at') THEN
    CREATE TRIGGER trigger_update_sites_updated_at
      BEFORE UPDATE ON public.sites
      FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
  END IF;
END$$;

-- 품질 체크 제약(음수 금지)
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='ck_work_records_nonneg') THEN
    ALTER TABLE public.work_records
      ADD CONSTRAINT ck_work_records_nonneg CHECK (COALESCE(days,0) >= 0 AND COALESCE(hours,0) >= 0);
  END IF;
  IF NOT EXISTS (SELECT 1 FROM pg_constraint WHERE conname='ck_expense_records_amount_nonneg') THEN
    ALTER TABLE public.expense_records
      ADD CONSTRAINT ck_expense_records_amount_nonneg CHECK (amount >= 0);
  END IF;
END$$;

-- =========================================================
-- 4) 중복 정리(유실 방지형) + 트림 + 업서트용 UNIQUE 인덱스/제약
-- =========================================================
-- (a) workers(name), sites(name) 공백 정리
UPDATE public.workers SET name = TRIM(name);
UPDATE public.sites   SET name = TRIM(name);

-- (b) workers 중복 제거(같은 name 한 개만 보존)
WITH ranked AS (
  SELECT id, name, ROW_NUMBER() OVER (PARTITION BY name ORDER BY id) rn
  FROM public.workers
)
DELETE FROM public.workers w USING ranked r
WHERE w.id=r.id AND r.rn>1;

-- (c) sites 중복 제거(같은 name 한 개만 보존)
WITH ranked AS (
  SELECT id, name, ROW_NUMBER() OVER (PARTITION BY name ORDER BY id) rn
  FROM public.sites
)
DELETE FROM public.sites s USING ranked r
WHERE s.id=r.id AND r.rn>1;

-- (d) UNIQUE 제약 보강(없으면 추가)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname='uk_workers_name'
      AND conrelid='public.workers'::regclass
  ) THEN
    ALTER TABLE public.workers
      ADD CONSTRAINT uk_workers_name UNIQUE(name);
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname='uk_sites_name'
      AND conrelid='public.sites'::regclass
  ) THEN
    ALTER TABLE public.sites
      ADD CONSTRAINT uk_sites_name UNIQUE(name);
  END IF;
END$$;

-- (e) work_records 중복 합산 후 1행만 보존 + 메모 병합(keep 외 메모만 추가)
WITH base AS (
  SELECT
    date, site, worker, id,
    COALESCE(days,0)  AS days,
    COALESCE(hours,0) AS hours,
    memo,
    MIN(id) OVER (PARTITION BY date, site, worker) AS keep_id
  FROM public.work_records
),
fold AS (
  SELECT date, site, worker, keep_id,
         SUM(days)  AS sum_days,
         SUM(hours) AS sum_hours
  FROM base
  GROUP BY 1,2,3,4
  HAVING COUNT(*) > 1
),
memos AS (
  SELECT date, site, worker, keep_id,
         STRING_AGG(COALESCE(memo,''), E'\n' ORDER BY id) AS dup_memo
  FROM base
  WHERE id <> keep_id
  GROUP BY 1,2,3,4
)
UPDATE public.work_records w
SET
  days  = f.sum_days,
  hours = f.sum_hours,
  memo  = NULLIF(
            TRIM(BOTH E'\n' FROM CONCAT_WS(E'\n', NULLIF(w.memo,''), NULLIF(m.dup_memo,'')))
          ,''
          )
FROM fold f
LEFT JOIN memos m
  ON m.date=f.date AND m.site=f.site AND m.worker=f.worker AND m.keep_id=f.keep_id
WHERE w.id = f.keep_id;

DELETE FROM public.work_records w
USING (
  SELECT id
  FROM (
    SELECT id,
           ROW_NUMBER() OVER (PARTITION BY date, site, worker ORDER BY id) AS rn
    FROM public.work_records
  ) t
  WHERE t.rn > 1
) d
WHERE w.id = d.id;

-- (f) expense_records 중복: 금액 키가 동일하므로 메모만 병합 후 나머지 삭제
WITH base AS (
  SELECT
    date, site, category, amount, id, memo,
    MIN(id) OVER (PARTITION BY date, site, category, amount) AS keep_id
  FROM public.expense_records
),
memos AS (
  SELECT date, site, category, amount, keep_id,
         STRING_AGG(COALESCE(memo,''), E'\n' ORDER BY id) AS dup_memo
  FROM base
  WHERE id <> keep_id
  GROUP BY 1,2,3,4,5
),
keeps AS (
  SELECT DISTINCT date, site, category, amount, keep_id FROM base
  WHERE keep_id IS NOT NULL
)
UPDATE public.expense_records e
SET memo = NULLIF(
             TRIM(BOTH E'\n' FROM CONCAT_WS(E'\n', NULLIF(e.memo,''), NULLIF(m.dup_memo,'')))
           ,''
           )
FROM keeps k
LEFT JOIN memos m
  ON m.date=k.date AND m.site=k.site AND m.category=k.category AND m.amount=k.amount AND m.keep_id=k.keep_id
WHERE e.id = k.keep_id;

DELETE FROM public.expense_records e
USING (
  SELECT id
  FROM (
    SELECT id,
           ROW_NUMBER() OVER (PARTITION BY date, site, category, amount ORDER BY id) AS rn
    FROM public.expense_records
  ) t
  WHERE t.rn > 1
) d
WHERE e.id = d.id;

-- (g) 업서트용 UNIQUE 인덱스 + 제약(없으면 생성)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes
    WHERE schemaname='public' AND indexname='uq_work_records_date_site_worker'
  ) THEN
    CREATE UNIQUE INDEX uq_work_records_date_site_worker
      ON public.work_records(date, site, worker);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname='uk_work_records_date_site_worker'
      AND conrelid='public.work_records'::regclass
  ) THEN
    ALTER TABLE public.work_records
      ADD CONSTRAINT uk_work_records_date_site_worker
      UNIQUE USING INDEX uq_work_records_date_site_worker;
  END IF;

  IF NOT EXISTS (
    SELECT 1 FROM pg_indexes
    WHERE schemaname='public' AND indexname='uq_expense_records_date_site_category_amount'
  ) THEN
    CREATE UNIQUE INDEX uq_expense_records_date_site_category_amount
      ON public.expense_records(date, site, category, amount);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_constraint
    WHERE conname='uk_expense_records_date_site_category_amount'
      AND conrelid='public.expense_records'::regclass
  ) THEN
    ALTER TABLE public.expense_records
      ADD CONSTRAINT uk_expense_records_date_site_category_amount
      UNIQUE USING INDEX uq_expense_records_date_site_category_amount;
  END IF;
END$$;

-- =========================================================
-- 5) (선택) 한글 테이블 → 표준 테이블 백필(있을 때만)
-- =========================================================
-- 노동자 → workers
DO $$
DECLARE has_kor boolean := EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='노동자');
        name_col text; daily_col text; hr_col text; ms_col text; sql text;
BEGIN
  IF NOT has_kor THEN RETURN; END IF;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='name') THEN 'name'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='이름') THEN '"이름"'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='성명') THEN '"성명"' END INTO name_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='daily') THEN 'daily'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='일당') THEN '"일당"'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='일급') THEN '"일급"' END INTO daily_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='hourly_rate') THEN 'hourly_rate'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='시급') THEN '"시급"' END INTO hr_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='monthly_salary') THEN 'monthly_salary'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='노동자' AND column_name='월급') THEN '"월급"' END INTO ms_col;

  IF name_col IS NULL THEN RETURN; END IF;

  sql := format($f$
    INSERT INTO public.workers(name, daily, hourly_rate, monthly_salary)
    SELECT %s,
           COALESCE(NULLIF(%s,0),0),
           COALESCE(NULLIF(%s,0),0),
           COALESCE(NULLIF(%s,0),0)
    FROM public."노동자"
    ON CONFLICT (name) DO UPDATE SET
      daily          = COALESCE(EXCLUDED.daily, public.workers.daily),
      hourly_rate    = COALESCE(EXCLUDED.hourly_rate, public.workers.hourly_rate),
      monthly_salary = COALESCE(EXCLUDED.monthly_salary, public.workers.monthly_salary);
  $f$, name_col, COALESCE(daily_col,'0'), COALESCE(hr_col,'0'), COALESCE(ms_col,'0'));
  EXECUTE sql;
END$$;

-- 사이트 → sites
DO $$
DECLARE has_kor boolean := EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='사이트');
        name_col text; addr_col text; mgr_col text; sql text;
BEGIN
  IF NOT has_kor THEN RETURN; END IF;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='사이트' AND column_name='name') THEN 'name'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='사이트' AND column_name='현장명') THEN '"현장명"'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='사이트' AND column_name='이름') THEN '"이름"' END INTO name_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='사이트' AND column_name='address') THEN 'address'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='사이트' AND column_name='주소') THEN '"주소"' END INTO addr_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='사이트' AND column_name='manager') THEN 'manager'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='사이트' AND column_name='담당자') THEN '"담당자"' END INTO mgr_col;

  IF name_col IS NULL THEN RETURN; END IF;

  sql := format($f$
    INSERT INTO public.sites(name, address, manager)
    SELECT %s, %s, %s
    FROM public."사이트"
    ON CONFLICT (name) DO UPDATE SET
      address = COALESCE(EXCLUDED.address, public.sites.address),
      manager = COALESCE(EXCLUDED.manager, public.sites.manager);
  $f$, name_col, COALESCE(addr_col,'NULL'), COALESCE(mgr_col,'NULL'));
  EXECUTE sql;
END$$;

-- 경비 → expense_records
DO $$
DECLARE has_kor boolean := EXISTS(SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='경비');
        d_col text; site_col text; worker_col text; cat_col text; amt_col text; loc_col text; addr_col text; memo_col text; sql text;
BEGIN
  IF NOT has_kor THEN RETURN; END IF;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='date') THEN 'date'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='일자') THEN '"일자"'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='사용일') THEN '"사용일"' END INTO d_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='site') THEN 'site'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='현장명') THEN '"현장명"'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='사이트') THEN '"사이트"' END INTO site_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='worker') THEN 'worker'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='작업자') THEN '"작업자"' END INTO worker_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='category') THEN 'category'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='항목') THEN '"항목"' END INTO cat_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='amount') THEN 'amount'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='금액') THEN '"금액"' END INTO amt_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='location') THEN 'location'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='사용처') THEN '"사용처"'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='vendor') THEN 'vendor' END INTO loc_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='address') THEN 'address'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='주소') THEN '"주소"' END INTO addr_col;

  SELECT CASE WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='memo') THEN 'memo'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='비고') THEN '"비고"'
              WHEN EXISTS (SELECT 1 FROM information_schema.columns WHERE table_schema='public' AND table_name='경비' AND column_name='메모') THEN '"메모"' END INTO memo_col;

  IF d_col IS NULL OR site_col IS NULL OR cat_col IS NULL OR amt_col IS NULL THEN RETURN; END IF;

  sql := format($f$
    INSERT INTO public.expense_records(date, site, worker, category, amount, location, address, memo)
    SELECT %s::date, %s, %s, %s, (%s)::numeric(12,2), %s, %s, %s
    FROM public."경비"
    ON CONFLICT (date, site, category, amount) DO NOTHING;
  $f$, d_col, site_col, COALESCE(worker_col,'NULL'), cat_col, amt_col, COALESCE(loc_col,'NULL'), COALESCE(addr_col,'NULL'), COALESCE(memo_col,'NULL'));
  EXECUTE sql;
END$$;

-- =========================================================
-- 6) 기존 시스템 테이블 → 표준 테이블 이관(있을 때만)
-- =========================================================
-- work_logs → work_records
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='work_logs')
     AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='workers')
     AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='sites')
  THEN
    INSERT INTO public.work_records (date, site, worker, days, memo)
    SELECT wl.date, s.name AS site, w.name AS worker,
           wl.md::NUMERIC(6,2) AS days, wl.note AS memo
    FROM public.work_logs wl
    JOIN public.sites   s ON wl.site_id = s.id
    JOIN public.workers w ON wl.worker_id = w.id
    ON CONFLICT (date, site, worker)
    DO UPDATE SET
      days = COALESCE(public.work_records.days,0) + COALESCE(EXCLUDED.days,0),
      memo = NULLIF(TRIM(BOTH E'\n' FROM CONCAT_WS(E'\n',
               NULLIF(public.work_records.memo,''), NULLIF(EXCLUDED.memo,''))), '');
  END IF;
END$$;

-- expenses → expense_records
DO $$
BEGIN
  IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='expenses')
     AND EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema='public' AND table_name='sites')
  THEN
    INSERT INTO public.expense_records (date, site, worker, category, amount, location, address, memo)
    SELECT e.date, s.name AS site, e.worker_name AS worker,
           COALESCE(e.category,'') AS category,
           e.amount::NUMERIC(12,2),
           e.vendor AS location, e.address, e.memo
    FROM public.expenses e
    JOIN public.sites   s ON e.site_id = s.id
    ON CONFLICT (date, site, category, amount) DO NOTHING;
  END IF;
END$$;

-- =========================================================
-- 7) 헬퍼 함수 (보존형/합산형 둘 다 제공)
-- =========================================================
-- 단건 작업 입력(보존형: 기존 있으면 변경 없음)
CREATE OR REPLACE FUNCTION public.log_work(
  p_date   date,
  p_site   text,
  p_worker text,
  p_days   numeric DEFAULT NULL,
  p_hours  numeric DEFAULT NULL,
  p_memo   text   DEFAULT NULL
) RETURNS public.work_records
LANGUAGE plpgsql AS $$
DECLARE v_rec public.work_records;
BEGIN
  p_site   := TRIM(p_site);
  p_worker := TRIM(p_worker);

  INSERT INTO public.sites(name)   VALUES (p_site)   ON CONFLICT (name) DO NOTHING;
  INSERT INTO public.workers(name) VALUES (p_worker) ON CONFLICT (name) DO NOTHING;

  INSERT INTO public.work_records(date, site, worker, days, hours, memo)
  VALUES (p_date, p_site, p_worker, p_days, p_hours, p_memo)
  ON CONFLICT (date, site, worker) DO NOTHING
  RETURNING * INTO v_rec;

  IF v_rec.id IS NULL THEN
    SELECT * INTO v_rec
    FROM public.work_records
    WHERE date = p_date AND site = p_site AND worker = p_worker;
  END IF;

  RETURN v_rec;
END $$;

-- 단건 작업 입력(합산형: 동일 키 존재 시 누계 + 메모 이어붙임)
CREATE OR REPLACE FUNCTION public.log_work_merge(
  p_date   date,
  p_site   text,
  p_worker text,
  p_days   numeric DEFAULT NULL,
  p_hours  numeric DEFAULT NULL,
  p_memo   text   DEFAULT NULL
) RETURNS public.work_records
LANGUAGE plpgsql AS $$
DECLARE v_rec public.work_records;
BEGIN
  p_site   := TRIM(p_site);
  p_worker := TRIM(p_worker);

  INSERT INTO public.sites(name)   VALUES (p_site)   ON CONFLICT (name) DO NOTHING;
  INSERT INTO public.workers(name) VALUES (p_worker) ON CONFLICT (name) DO NOTHING;

  INSERT INTO public.work_records(date, site, worker, days, hours, memo)
  VALUES (p_date, p_site, p_worker, p_days, p_hours, p_memo)
  ON CONFLICT (date, site, worker) DO UPDATE
    SET days  = COALESCE(public.work_records.days, 0)  + COALESCE(EXCLUDED.days, 0),
        hours = COALESCE(public.work_records.hours, 0) + COALESCE(EXCLUDED.hours, 0),
        memo  = NULLIF(TRIM(BOTH E'\n' FROM CONCAT_WS(E'\n',
                  NULLIF(public.work_records.memo,''), NULLIF(EXCLUDED.memo,'')))
               ,'')
  RETURNING * INTO v_rec;

  RETURN v_rec;
END $$;

-- 단건 경비 입력(보존형: 동일 키 존재 시 무시)
CREATE OR REPLACE FUNCTION public.log_expense(
  p_date     date,
  p_site     text,
  p_category text,
  p_amount   numeric,
  p_worker   text DEFAULT NULL,
  p_location text DEFAULT NULL,
  p_address  text DEFAULT NULL,
  p_memo     text DEFAULT NULL
) RETURNS public.expense_records
LANGUAGE plpgsql AS $$
DECLARE v_rec public.expense_records;
BEGIN
  p_site := TRIM(p_site);
  INSERT INTO public.sites(name) VALUES (p_site) ON CONFLICT (name) DO NOTHING;

  INSERT INTO public.expense_records(date, site, worker, category, amount, location, address, memo)
  VALUES (p_date, p_site, NULLIF(TRIM(COALESCE(p_worker,'')),''), p_category, p_amount, p_location, p_address, p_memo)
  ON CONFLICT (date, site, category, amount) DO NOTHING
  RETURNING * INTO v_rec;

  IF v_rec.id IS NULL THEN
    SELECT * INTO v_rec
    FROM public.expense_records
    WHERE date=p_date AND site=p_site AND category=p_category AND amount=p_amount
    LIMIT 1;
  END IF;

  RETURN v_rec;
END $$;

-- 벌크 입력(보존형)
CREATE OR REPLACE FUNCTION public.bulk_log_work(p_rows jsonb)
RETURNS integer LANGUAGE plpgsql AS $$
DECLARE r jsonb; cnt int:=0;
BEGIN
  FOR r IN SELECT * FROM jsonb_array_elements(p_rows) LOOP
    PERFORM public.log_work(
      (r->>'date')::date,
      r->>'site',
      r->>'worker',
      NULLIF(r->>'days','')::numeric,
      NULLIF(r->>'hours','')::numeric,
      r->>'memo'
    );
    cnt := cnt + 1;
  END LOOP;
  RETURN cnt;
END $$;

-- 벌크 입력(합산형)
CREATE OR REPLACE FUNCTION public.bulk_log_work_merge(p_rows jsonb)
RETURNS integer LANGUAGE plpgsql AS $$
DECLARE r jsonb; cnt int:=0;
BEGIN
  FOR r IN SELECT * FROM jsonb_array_elements(p_rows) LOOP
    PERFORM public.log_work_merge(
      (r->>'date')::date,
      r->>'site',
      r->>'worker',
      NULLIF(r->>'days','')::numeric,
      NULLIF(r->>'hours','')::numeric,
      r->>'memo'
    );
    cnt := cnt + 1;
  END LOOP;
  RETURN cnt;
END $$;

CREATE OR REPLACE FUNCTION public.bulk_log_expense(p_rows jsonb)
RETURNS integer LANGUAGE plpgsql AS $$
DECLARE r jsonb; cnt int:=0;
BEGIN
  FOR r IN SELECT * FROM jsonb_array_elements(p_rows) LOOP
    PERFORM public.log_expense(
      (r->>'date')::date,
      r->>'site',
      r->>'category',
      (r->>'amount')::numeric,
      r->>'worker',
      r->>'location',
      r->>'address',
      r->>'memo'
    );
    cnt := cnt + 1;
  END LOOP;
  RETURN cnt;
END $$;

-- (선택) 재계산 헬퍼
CREATE OR REPLACE FUNCTION public.recalc_work_records(p_from DATE, p_to DATE)
RETURNS void LANGUAGE plpgsql AS $$
BEGIN
  -- 트리거 유도를 위한 더미 업데이트
  UPDATE public.work_records wr
     SET memo = wr.memo
   WHERE wr.date BETWEEN p_from AND p_to;
END $$;

-- =========================================================
-- 8) RLS (정책명 단위로 개별 확인/생성)  ※ 운영 시 실제 정책으로 강화 권장
-- =========================================================
DO $$
DECLARE
  rel REGCLASS;
  rels REGCLASS[] := ARRAY[
    'public.workers'::regclass,
    'public.sites'::regclass,
    'public.work_records'::regclass,
    'public.expense_records'::regclass,
    'public.system_config'::regclass
  ];
BEGIN
  -- RLS 활성화
  FOREACH rel IN ARRAY rels LOOP
    EXECUTE format('ALTER TABLE %s ENABLE ROW LEVEL SECURITY;', rel);
  END LOOP;

  -- 정책별로 존재 확인 후 생성
  FOREACH rel IN ARRAY rels LOOP
    IF NOT EXISTS (SELECT 1 FROM pg_policy p WHERE p.polrelid = rel AND p.polname = 'all select') THEN
      EXECUTE format('CREATE POLICY "all select" ON %s FOR SELECT USING (true);', rel);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policy p WHERE p.polrelid = rel AND p.polname = 'all insert') THEN
      EXECUTE format('CREATE POLICY "all insert" ON %s FOR INSERT WITH CHECK (true);', rel);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policy p WHERE p.polrelid = rel AND p.polname = 'all update') THEN
      EXECUTE format('CREATE POLICY "all update" ON %s FOR UPDATE USING (true);', rel);
    END IF;
    IF NOT EXISTS (SELECT 1 FROM pg_policy p WHERE p.polrelid = rel AND p.polname = 'all delete') THEN
      EXECUTE format('CREATE POLICY "all delete" ON %s FOR DELETE USING (true);', rel);
    END IF;
  END LOOP;
END $$;

COMMIT;
